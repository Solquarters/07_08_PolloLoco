<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/endboss.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/endboss.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Class representing the end boss in the game.
 * 
 * @extends MoveableObject
 * 
 * @property {Audio} angry_sound - The sound played when the boss is triggered or angry.
 * @property {Audio} hitBoss_sound - The sound played when the boss is hit by the player.
 * @property {Audio} bossDead_sound - The sound played when the boss dies.
 * @property {Audio} bossHit_sound - Another sound played when the boss is hit by the player.
 * @property {number} x - The initial x-position of the boss.
 * @property {boolean} isAlive - Determines if the boss is still alive.
 * @property {number} y - The y-position of the boss.
 * @property {number} height - The height of the boss.
 * @property {number} width - The width of the boss.
 * @property {number} speed - The speed of the boss.
 * @property {boolean} isTriggered - Determines if the boss is triggered by the player's proximity.
 * @property {number} deadAnimationFrame - Tracks the current frame in the death animation.
 * @property {number} lastJumpTimer - Time since the last jump.
 * @property {number} newTimeAfterJump - Time for the next possible jump.
 * @property {number} oldEnergy - The boss's energy level before recent actions.
 * @property {object} offset - The collision offset values for the boss.
 * @property {Array&lt;string>} IMAGES_WALKING - Array of image paths for the walking animation.
 * @property {Array&lt;string>} IMAGES_ATTACKING - Array of image paths for the attacking animation.
 * @property {Array&lt;string>} IMAGES_HURT - Array of image paths for the hurt animation.
 * @property {Array&lt;string>} IMAGES_DEAD - Array of image paths for the death animation.
 * @property {number} currentImage - The index of the current image being displayed for animation.
 */
class Endboss extends MoveableObject {
  angry_sound = new Audio("./sounds/Pollo Loco Sound/angrychicken.ogg");
  hitBoss_sound = new Audio("./sounds/Pollo Loco Sound/bosshit.ogg");
  bossDead_sound = new Audio("./sounds/Pollo Loco Sound/chickenfunny.ogg");
  bossHit_sound = new Audio("./sounds/Pollo Loco Sound/bosshit.ogg");
  x = 7800;

  isAlive = true;

  y = 50;
  height = 420;
  width = 280;
  isAlive = true;
  speed = 3;
  isTriggered = false;
  deadAnimationFrame = 0;

  lastJumpTimer = 0;
  newTimeAfterJump = 0;

  oldEnergy = 100;

  offset = {
    top: 120,
    bottom: 40,
    left: 80,
    right: 60,
  };

  IMAGES_WALKING = [
    "./img/4_enemie_boss_chicken/2_alert/G5.png",
    "./img/4_enemie_boss_chicken/2_alert/G6.png",
    "./img/4_enemie_boss_chicken/2_alert/G7.png",
    "./img/4_enemie_boss_chicken/2_alert/G8.png",
    "./img/4_enemie_boss_chicken/2_alert/G9.png",
    "./img/4_enemie_boss_chicken/2_alert/G10.png",
    "./img/4_enemie_boss_chicken/2_alert/G11.png",
    "./img/4_enemie_boss_chicken/2_alert/G12.png",
  ];

  IMAGES_ATTACKING = [
    "./img/4_enemie_boss_chicken/3_attack/G13.png",
    "./img/4_enemie_boss_chicken/3_attack/G14.png",
    "./img/4_enemie_boss_chicken/3_attack/G15.png",
    "./img/4_enemie_boss_chicken/3_attack/G16.png",
    "./img/4_enemie_boss_chicken/3_attack/G17.png",
    "./img/4_enemie_boss_chicken/3_attack/G18.png",
    "./img/4_enemie_boss_chicken/3_attack/G19.png",
    "./img/4_enemie_boss_chicken/3_attack/G20.png",
  ];

  IMAGES_HURT = [
    "./img/4_enemie_boss_chicken/4_hurt/G21.png",
    "./img/4_enemie_boss_chicken/4_hurt/G22.png",
    "./img/4_enemie_boss_chicken/4_hurt/G23.png",
  ];

  IMAGES_DEAD = [
    "./img/4_enemie_boss_chicken/5_dead/G24.png",
    "./img/4_enemie_boss_chicken/5_dead/G24.png",
    "./img/4_enemie_boss_chicken/5_dead/G25.png",
    "./img/4_enemie_boss_chicken/5_dead/G25.png",
    "./img/4_enemie_boss_chicken/5_dead/G26.png",
    "./img/4_enemie_boss_chicken/5_dead/G26.png",
  ];

  currentImage = 0;

  constructor() {
    super().loadImage("./img/3_enemies_chicken/chicken_normal/1_walk/1_w.png");
    this.loadImages(this.IMAGES_WALKING);
    this.loadImages(this.IMAGES_ATTACKING);
    this.loadImages(this.IMAGES_HURT);
    this.loadImages(this.IMAGES_DEAD);

    this.applyGravity();
    this.animate();

    this.addAudioToGlobalArray();
  }


  /**
 * Adds end boss audio objects to the global audio array for collective muting.
 */
addAudioToGlobalArray() {
globalAudioArray.push(
  this.angry_sound,
  this.hitBoss_sound,
  this.bossDead_sound,
  this.bossHit_sound
);
}

/**
 * Makes the boss jump, randomizing the jump height and horizontal displacement.
 */
  jump() {
    this.speedY = 25 + Math.random() * 20;
    this.x = this.x + Math.random() * 70;
  }


  /**
 * Animates the end boss' movement, attack, and other states, handling conditions for death, hurt, or triggering boss behavior.
 * Runs at intervals to simulate continuous animation.
 */
  animate() {
    //added little delay before accessing character attributes to catch access error
    this.lastJumpTimer = new Date().getTime();

    //Handle animation and states
    setTimeout(() => {
      setStoppableInterval(() => {



        if (this.isDead()) {

          //Handle beginning of death animation
          if (this.deadAnimationFrame == 0) {
            this.currentImage = 0;
          }
          //Handle end of death animation 
          if (this.deadAnimationFrame == this.IMAGES_DEAD.length - 1) {
            // this.y = 100;
            // setTimeout(() => {
            //   stopGame();
            //   this.world.levelAmbience.pause();
            //   document.getElementById("gameWonOverlayDivId").style.display =
            //     "flex";
            // }, 800);
            this.handleGameWon();
            return;
          }

          // this.deadAnimationFrame++;
          // this.playAnimation(this.IMAGES_DEAD);
          // document.getElementById("bossBarDivId").style.display = "none";
          this.continueDeathAnimation();
          return;
        }



        if (this.isHurt()) {
          this.playAnimation(this.IMAGES_HURT);
          this.bossHit_sound.play();
          return;
        }

        if (this.x - this.world.character.x &lt;= 320 || this.energy &lt; 100) {
          this.isTriggered = true;
          document.getElementById("bossBarDivId").style.display = "block";
        } else {
          this.isTriggered = false;
        }

        if (!this.isTriggered) {
          this.playAnimation(this.IMAGES_WALKING);
        }

        // if (this.isTriggered &amp;&amp; this.world.character.x &lt; this.x) {
        //   this.otherDirection = false;
        //   this.playAnimation(this.IMAGES_ATTACKING);
        //   // this.moveLeft();
        // }

        // if (this.isTriggered &amp;&amp; this.world.character.x >= this.x) {
        //   this.otherDirection = true;
        //   this.playAnimation(this.IMAGES_ATTACKING);
        //   this.moveRight();
        // }
        this.handleTriggeredMovement();

      }, 1000 / 8);
    }, 150);


    //Handle movement and sound
    setTimeout(() => {
      setStoppableInterval(() => {



        // if (this.x - this.world.character.x &lt; 800 &amp;&amp; !this.isDead()) {
        //   this.angry_sound.play();
        // } else if (this.isDead()) {
        //   this.angry_sound.pause();
        //   this.bossDead_sound.play();
        // }
        this.handleNearbyOrDeathSound();


        // if (
        //   this.isTriggered &amp;&amp;
        //   this.world.character.x &lt;= this.x &amp;&amp;
        //   !this.isDead()
        // ) {
        //   this.moveLeft();

        //   this.newTimeAfterJump = new Date().getTime();

        //   if (this.newTimeAfterJump - this.lastJumpTimer > 1600) {
        //     this.jump();
        //     this.newTimeAfterJump = new Date().getTime();
        //     this.lastJumpTimer = new Date().getTime();
        //   }
        // }
this.handleMoveLeftIfConditionIsTrue();


        // if (
        //   this.isTriggered &amp;&amp;
        //   this.world.character.x > this.x &amp;&amp;
        //   !this.isDead()
        // ) {
        //   this.moveRight();
        //   this.newTimeAfterJump = new Date().getTime();

        //   if (this.newTimeAfterJump - this.lastJumpTimer > 1600) {
        //     this.jump();
        //     this.newTimeAfterJump = new Date().getTime();
        //     this.lastJumpTimer = new Date().getTime();
        //   }
        // }
        this.handleMoveRightIfConditionIsTrue();



      }, 1000 / 60);
    }, 300);
  }


  /**
 * Handles boss movement to the right if the character is to the right of the boss, including jump logic if conditions are met.
 */
  handleMoveRightIfConditionIsTrue(){
    if (
      this.isTriggered &amp;&amp;
      this.world.character.x > this.x &amp;&amp;
      !this.isDead()
    ) {
      this.moveRight();
      this.newTimeAfterJump = new Date().getTime();

      if (this.newTimeAfterJump - this.lastJumpTimer > 1600) {
        this.jump();
        this.newTimeAfterJump = new Date().getTime();
        this.lastJumpTimer = new Date().getTime();
      }
    }
  }


  /**
 * Handles boss movement to the left if the character is to the left of the boss, including jump logic if conditions are met.
 */
  handleMoveLeftIfConditionIsTrue(){
    if (
      this.isTriggered &amp;&amp;
      this.world.character.x &lt;= this.x &amp;&amp;
      !this.isDead()
    ) {
      this.moveLeft();

      this.newTimeAfterJump = new Date().getTime();

      if (this.newTimeAfterJump - this.lastJumpTimer > 1600) {
        this.jump();
        this.newTimeAfterJump = new Date().getTime();
        this.lastJumpTimer = new Date().getTime();
      }
    }

  }

/**
 * Plays the angry sound when the player is nearby and plays the boss' death sound when the boss dies.
 */
  handleNearbyOrDeathSound(){
    if (this.x - this.world.character.x &lt; 800 &amp;&amp; !this.isDead()) {
      this.angry_sound.play();
    } else if (this.isDead()) {
      this.angry_sound.pause();
      this.bossDead_sound.play();
    }
  }

  /**
 * Displays the game won screen after the boss dies, pauses background sound, and stops the game.
 */
  handleGameWon(){
    this.y = 100;
    setTimeout(() => {
      stopGame();
      this.world.levelAmbience.pause();
      document.getElementById("gameWonOverlayDivId").style.display =
        "flex";
    }, 800);

  }

  /**
 * Continues the boss' death animation and hides the boss' health bar.
 */
  continueDeathAnimation(){
    this.deadAnimationFrame++;
          this.playAnimation(this.IMAGES_DEAD);
          document.getElementById("bossBarDivId").style.display = "none";
  }

/**
 * Manages the boss' attack and movement based on the player's position when the boss is triggered.
 * Handles animation for attack sequences.
 */
  handleTriggeredMovement(){
    if (this.isTriggered &amp;&amp; this.world.character.x &lt; this.x) {
      this.otherDirection = false;
      this.playAnimation(this.IMAGES_ATTACKING);
      // this.moveLeft();
    }

    if (this.isTriggered &amp;&amp; this.world.character.x >= this.x) {
      this.otherDirection = true;
      this.playAnimation(this.IMAGES_ATTACKING);
      this.moveRight();
    }
  }











}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Character.html">Character</a></li><li><a href="Endboss.html">Endboss</a></li><li><a href="Level.html">Level</a></li><li><a href="MoveableObject.html">MoveableObject</a></li><li><a href="ThrowableObject.html">ThrowableObject</a></li><li><a href="World.html">World</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkOrientation">checkOrientation</a></li><li><a href="global.html#enterFullscreen">enterFullscreen</a></li><li><a href="global.html#exitFullscreen">exitFullscreen</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initLevel">initLevel</a></li><li><a href="global.html#returnChickensForLevel">returnChickensForLevel</a></li><li><a href="global.html#returnCoinsAndBottlesForLevel">returnCoinsAndBottlesForLevel</a></li><li><a href="global.html#returnLevelBackgroundArray">returnLevelBackgroundArray</a></li><li><a href="global.html#setStoppableInterval">setStoppableInterval</a></li><li><a href="global.html#stopGame">stopGame</a></li><li><a href="global.html#toggleAllAudio">toggleAllAudio</a></li><li><a href="global.html#toggleFullscreen">toggleFullscreen</a></li><li><a href="global.html#toggleInfoOverlay">toggleInfoOverlay</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Thu Sep 19 2024 20:43:06 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
